<!DOCTYPE html>
<html>
  <head>
    <title>rapport.md</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

    <style>
      /* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
      /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

      html {
        display: flex;
        justify-content: center;
      }

      body {
        background-color: rgb(224, 215, 209);
        color: #1f1e1e;
        /* box-shadow: 0 0 17px 0 #d6d4d4; */
        width: clamp(15em, 85%, 67em);
        font-family: var(
          --vscode-markdown-font-family,
          -apple-system,
          BlinkMacSystemFont,
          "Segoe WPC",
          "Segoe UI",
          "Ubuntu",
          "Droid Sans",
          sans-serif
        );
        font-size: var(--vscode-markdown-font-size, 14px);
        padding: 0 26px;
        line-height: var(--vscode-markdown-line-height, 22px);
        word-wrap: break-word;
      }

      img {
        border-radius: 1em;
        box-shadow: 0 0 5px 0 #888;
      }

      #code-csp-warning {
        position: fixed;
        top: 0;
        right: 0;
        color: white;
        margin: 16px;
        text-align: center;
        font-size: 12px;
        font-family: sans-serif;
        background-color: #444444;
        cursor: pointer;
        padding: 6px;
        box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.25);
      }

      #code-csp-warning:hover {
        text-decoration: none;
        background-color: #007acc;
        box-shadow: 2px 2px 2px rgba(0, 0, 0, 0.25);
      }

      body.scrollBeyondLastLine {
        margin-bottom: calc(100vh - 22px);
      }

      body.showEditorSelection .code-line {
        position: relative;
      }

      body.showEditorSelection .code-active-line:before,
      body.showEditorSelection .code-line:hover:before {
        content: "";
        display: block;
        position: absolute;
        top: 0;
        left: -12px;
        height: 100%;
      }

      body.showEditorSelection li.code-active-line:before,
      body.showEditorSelection li.code-line:hover:before {
        left: -30px;
      }

      .vscode-light.showEditorSelection .code-active-line:before {
        border-left: 3px solid rgba(0, 0, 0, 0.15);
      }

      .vscode-light.showEditorSelection .code-line:hover:before {
        border-left: 3px solid rgba(0, 0, 0, 0.4);
      }

      .vscode-light.showEditorSelection .code-line .code-line:hover:before {
        border-left: none;
      }

      .vscode-dark.showEditorSelection .code-active-line:before {
        border-left: 3px solid rgba(255, 255, 255, 0.4);
      }

      .vscode-dark.showEditorSelection .code-line:hover:before {
        border-left: 3px solid rgba(255, 255, 255, 0.6);
      }

      .vscode-dark.showEditorSelection .code-line .code-line:hover:before {
        border-left: none;
      }

      .vscode-high-contrast.showEditorSelection .code-active-line:before {
        border-left: 3px solid rgba(255, 160, 0, 0.7);
      }

      .vscode-high-contrast.showEditorSelection .code-line:hover:before {
        border-left: 3px solid rgba(255, 160, 0, 1);
      }

      .vscode-high-contrast.showEditorSelection
        .code-line
        .code-line:hover:before {
        border-left: none;
      }

      img {
        max-width: 100%;
        max-height: 100%;
      }

      a {
        text-decoration: none;
      }

      a:hover {
        text-decoration: underline;
      }

      a:focus,
      input:focus,
      select:focus,
      textarea:focus {
        outline: 1px solid -webkit-focus-ring-color;
        outline-offset: -1px;
      }

      hr {
        border: 0;
        height: 2px;
        border-bottom: 2px solid;
      }

      h1 {
        padding-bottom: 0.3em;
        line-height: 1.2;
        border-bottom-width: 1px;
        border-bottom-style: solid;
      }

      h1,
      h2,
      h3 {
        font-weight: normal;
      }

      table {
        border-collapse: collapse;
      }

      table > thead > tr > th {
        text-align: left;
        border-bottom: 1px solid;
      }

      table > thead > tr > th,
      table > thead > tr > td,
      table > tbody > tr > th,
      table > tbody > tr > td {
        padding: 5px 10px;
      }

      table > tbody > tr + tr > td {
        border-top: 1px solid;
      }

      blockquote {
        margin: 0 7px 0 5px;
        padding: 0 16px 0 10px;
        border-left-width: 5px;
        border-left-style: solid;
      }

      code {
        font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New",
          monospace, "Droid Sans Fallback";
        font-size: 1em;
        line-height: 1.357em;
      }

      body.wordWrap pre {
        white-space: pre-wrap;
      }

      pre:not(.hljs),
      pre.hljs code > div {
        padding: 16px;
        border-radius: 3px;
        overflow: auto;
      }

      pre code {
        color: var(--vscode-editor-foreground);
        tab-size: 4;
      }

      /** Theming */

      .vscode-light pre {
        background-color: rgba(220, 220, 220, 0.4);
      }

      .vscode-dark pre {
        background-color: rgba(10, 10, 10, 0.4);
      }

      .vscode-high-contrast pre {
        background-color: rgb(0, 0, 0);
      }

      .vscode-high-contrast h1 {
        border-color: rgb(0, 0, 0);
      }

      .vscode-light table > thead > tr > th {
        border-color: rgba(0, 0, 0, 0.69);
      }

      .vscode-dark table > thead > tr > th {
        border-color: rgba(255, 255, 255, 0.69);
      }

      .vscode-light h1,
      .vscode-light hr,
      .vscode-light table > tbody > tr + tr > td {
        border-color: rgba(0, 0, 0, 0.18);
      }

      .vscode-dark h1,
      .vscode-dark hr,
      .vscode-dark table > tbody > tr + tr > td {
        border-color: rgba(255, 255, 255, 0.18);
      }
    </style>

    <style>
      /* Tomorrow Theme */
      /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
      /* Original theme - https://github.com/chriskempson/tomorrow-theme */

      /* Tomorrow Comment */
      .hljs-comment,
      .hljs-quote {
        color: #8e908c;
      }

      /* Tomorrow Red */
      .hljs-variable,
      .hljs-template-variable,
      .hljs-tag,
      .hljs-name,
      .hljs-selector-id,
      .hljs-selector-class,
      .hljs-regexp,
      .hljs-deletion {
        color: #c82829;
      }

      /* Tomorrow Orange */
      .hljs-number,
      .hljs-built_in,
      .hljs-builtin-name,
      .hljs-literal,
      .hljs-type,
      .hljs-params,
      .hljs-meta,
      .hljs-link {
        color: #f5871f;
      }

      /* Tomorrow Yellow */
      .hljs-attribute {
        color: #eab700;
      }

      /* Tomorrow Green */
      .hljs-string,
      .hljs-symbol,
      .hljs-bullet,
      .hljs-addition {
        color: #718c00;
      }

      /* Tomorrow Blue */
      .hljs-title,
      .hljs-section {
        color: #4271ae;
      }

      /* Tomorrow Purple */
      .hljs-keyword,
      .hljs-selector-tag {
        color: #8959a8;
      }

      .hljs {
        display: block;
        overflow-x: auto;
        color: #4d4d4c;
        padding: 0.5em;
      }

      .hljs-emphasis {
        font-style: italic;
      }

      .hljs-strong {
        font-weight: bold;
      }
    </style>

    <style>
      /*
 * Markdown PDF CSS
 */

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI",
          "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
        padding: 0 12px;
      }

      pre {
        background-color: #f8f8f8;
        border: 1px solid #cccccc;
        border-radius: 3px;
        overflow-x: auto;
        white-space: pre-wrap;
        overflow-wrap: break-word;
      }

      pre:not(.hljs) {
        padding: 23px;
        line-height: 19px;
      }

      blockquote {
        background: rgba(127, 127, 127, 0.1);
        border-color: rgba(0, 122, 204, 0.5);
      }

      .emoji {
        height: 1.4em;
      }

      code {
        font-size: 14px;
        line-height: 19px;
      }

      /* for inline code */
      :not(pre):not(.hljs) > code {
        color: #c9ae75; /* Change the old color so it seems less like an error */
        font-size: inherit;
      }

      /* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
      .page {
        page-break-after: always;
      }
    </style>

    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
  </head>
  <body>
    <script>
      mermaid.initialize({
        startOnLoad: true,
        theme:
          document.body.classList.contains("vscode-dark") ||
          document.body.classList.contains("vscode-high-contrast")
            ? "dark"
            : "default"
      });
    </script>
    <h1 id="teknisk-rapport-caspar">Teknisk rapport Caspar</h1>
    <p>
      En teknisk rapport för utvecklingen av Glare, en flashcardstjänst. En
      rapport som jag successivt antecknat i, genom produktens utveckling. Till
      en början hänvisa jag till githublänkar som markerar kodsnippets som jag
      utvecklat, dock ganska snabbt insåg jag att koden förändras och utvecklas,
      vilket resulterade i att länkarna inte uppdaterar korrekt rader kod.
      Därför har jag gjort all kod &quot;collapsable&quot;, så för att se kod
      behöver du trycka på pilarna. Testa nedan
    </p>
    <details>
      <summary>Visa kod:</summary>
      <pre
        class="hljs"
      ><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUserNoob</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (userSeeThis) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
<span class="hljs-comment">// Snyggt! Nu vet du hur du går till väga resten av rapporten</span>
</div></code></pre>
    </details>
    <p>
      För att underlätta förståelsen av alla snippets så har jag modifierat
      koden så den följer samma röda tråd som beskrivningen. Detta för att
      undvika distraherande kod som kan vilseleda förståelsen av själva
      funktionalliteten.
    </p>
    <h2 id="2002-25">20/02-25</h2>
    <h3 id="fetchcards">fetchCards</h3>
    <p>
      Till en allra första början skapade vi en .json fil som hade strukturen vi
      förväntade oss att jobba med framöver
    </p>
    <details>
      <summary>decks.json</summary>
      <pre class="hljs"><code><div>{
  <span class="hljs-attr">"decks"</span>: [
    {
      <span class="hljs-attr">"title"</span>: <span class="hljs-number">1</span>:ans multiplikation,
      <span class="hljs-attr">"cards"</span>: [
        {
          <span class="hljs-attr">"question"</span>:<span class="hljs-string">"1 x 1 = ?"</span>,
          <span class="hljs-attr">"answer"</span> : <span class="hljs-string">"1"</span>
        },
        ...
      ]
    },
    ...
  ]
}
</div></code></pre>
    </details>
    <p>
      Som första steg ville jag se ifall jag kunde fetcha information från en
      .json fil
    </p>
    <details>
      <summary>Visa kod för: src/components/FlashCard.vue</summary>
      <pre class="hljs"><code><div>&lt;script setup&gt;
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDecks</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">"/decks.json"</span>);
  <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> response.json();
  decks.value = data;
}

<span class="hljs-keyword">const</span> decks = ref([]);
getDecks();

<span class="hljs-built_in">console</span>.log(decks.value);
&lt;<span class="hljs-regexp">/script&gt;

&lt;template&gt;
  &lt;h1&gt;hej från flashcard&lt;/</span>h1&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"deck in decks"</span>&gt;</span>{{ deck.title }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></span>
&lt;<span class="hljs-regexp">/template&gt;
</span></div></code></pre>
    </details>
    <hr />
    <h2 id="2102-25">21/02-25</h2>
    <h3 id="revealanswer">revealAnswer</h3>
    <p>
      Jag fick idén att hämta kortlek och respektives kort genom att lyssna
      vilket vika värden som finns i URL:n, så när man skriver
      &quot;/collection/1/2&quot; i webläsaren ska man komma till andra kortet i
      kortlek nr 1.
      <br />
      Det kändes som en bra lösning då det ända man behöver göra senare för att
      navigera mellan kort är att addera eller subtrahera värdena från urln,
      plus det ger användaren möjlighet att navigera sig snabbt till en lek
      genom att spara länkar. Det verkar med andra ord användarvänligt.
      <br />
      Utmaningen var att kortet skulle lyssna på url:n både vid uppdatering av
      sidan och när man anger nya värden i urln, detta löste jag med genom att
      implementera onMounted() och on befoureRouteUpdate()
      <br />
      Implementerade även en toggle, så när man trycker på space, ska frågan och
      svar togglas fram och tillbaka, bara för att jag personligen är en
      keyboard fantast.
    </p>
    <p><img src="images/reveal-card.gif" alt="reveal card with space" /></p>
    <details>
      <summary>Visa kod för: src/components/FlashCard.vue</summary>
      <pre
        class="hljs"
      ><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">revealAnswer</span>(<span class="hljs-params"></span>) </span>{
  hideAnswer.value = <span class="hljs-literal">false</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"reveal"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleKeyDown</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">if</span> (event.code === <span class="hljs-string">"space"</span> || event.key === <span class="hljs-string">" "</span>) {
    revealAnswer();
  }
}

<span class="hljs-comment">// Update deckId and cardId when page refreshes</span>
onMounted(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> getDecks();

  watchEffect(
    <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> [route.params.deckId, route.params.cardNr],
    (currentDeck.value = decks.value[route.params.deckId]),
    (currentCard.value = currentDeck.value.cards[route.params.cardNr]),
    <span class="hljs-built_in">console</span>.log(currentDeck.value),
    <span class="hljs-built_in">console</span>.log(currentCard.value)
  );

  <span class="hljs-comment">// Create eventlistener to any keydown</span>
  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"keydown"</span>, handleKeyDown);
});

onBeforeUnmount(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">"keydown"</span>, handleKeyDown);
});

<span class="hljs-comment">// Update deckId and cardId when url changes</span>
onBeforeRouteUpdate(<span class="hljs-keyword">async</span> (to, <span class="hljs-keyword">from</span>) =&gt; {
  deckId = to.params.deckId;
  cardNr = to.params.cardNr;
  currentDeck.value = decks.value[deckId];
  currentCard.value = currentDeck.value.cards[cardNr];
});
</div></code></pre>
    </details>
    <hr />
    <h3 id="parprogrammering-zaher">Parprogrammering Zaher</h3>
    <p>
      Jag och zaher har tillsammans rätt ut så man kan mata in en deck prop till
      komponenten CardCollection så att det visas ut en mapp på sidan som leder
      till motsvarande kortlek. Först tänkte vi mata in :title=title och
      :count=count men insåg sedan att det räcker med att mata in :deck=deck där
      deck är ett objekt så får komponenten själv ta fram titeln och räkna ut
      antalet kort i count.
    </p>
    <details>
      <summary>Visa kod för: src/view/CollectionView.vue</summary>
      <pre class="hljs"><code><div>&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- &lt;FlashCard /&gt; --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span>
      <span class="hljs-attr">:key</span>=<span class="hljs-string">"deck.id"</span>
      <span class="hljs-attr">id</span>=<span class="hljs-string">"nodeco"</span>
      <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(deck, index) in decks"</span>
      <span class="hljs-attr">:to</span>=<span class="hljs-string">"`/collection/${index + 1}/1`"</span>
    &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">CardCollection</span> <span class="hljs-attr">:deck</span>=<span class="hljs-string">"deck"</span> /&gt;</span> // Notera :deck
    <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;<span class="hljs-regexp">/template&gt;

</span></div></code></pre>
    </details>
    <hr />
    <h2 id="2202-25">22/02-25</h2>
    <h3 id="helg-refaktorering-med-pinia-%F0%9F%8D%8D">
      Helg refaktorering med pinia 🍍
    </h3>
    <p>
      Istället för att fetcha korten dirrekt i FlashCard.vue så skapade jag en
      store för all flashcard funktionallitet där jag skapade både decks
      variabel och fetchCards funktion. Syftet är att man lätt och smitidigt ska
      kunna sammla alla funktioner som berör flashcards på ett och samma ställe.
      Utmaningen var att få det asyncrona att jobba för mig. Först skapade jag
      fetchen i getters, men fick senare svar på att det är inte menat att
      getters ska vara asynkrona.
    </p>
    <details>
      <summary>Visa kod för: src/stores/flashcards.js</summary>
      <pre
        class="hljs"
      ><code><div><span class="hljs-keyword">import</span> { defineStore } <span class="hljs-keyword">from</span> <span class="hljs-string">"pinia"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useFlashcard = defineStore(<span class="hljs-string">"flashcard"</span>, {
  <span class="hljs-attr">state</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    <span class="hljs-attr">decks</span>: []
  }),
  <span class="hljs-attr">actions</span>: {
    <span class="hljs-keyword">async</span> fetchDecks() {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">"/decks.json"</span>);
      <span class="hljs-keyword">this</span>.decks = <span class="hljs-keyword">await</span> response.json();
    }
  },
  <span class="hljs-attr">getters</span>: {
    <span class="hljs-comment">// getters</span>
  }
});
</div></code></pre>
    </details>
    <hr />
    <h2 id="2302-25">23/02-25</h2>
    <h3 id="pinia-forts%C3%A4ttning">Pinia fortsättning</h3>
    <p>
      För att i framtiden kunna möjligöra för användaren att skapa egna kort och
      kortlekar så implementerade jag createCard(title, question, answer) och
      createDeck(title, decks=[]) och med hjälp av dom fixade jag även en
      dummydeck som skapar en sammling kortlekar med gångertabellerna 1-10, så
      vi har data att bygga vår appikation runt.
      <br />
      <br />
      Anledningen till att jag vill generera dummyDeck istället för att
      modifiera .json filen är för att det blir repetativt arbete att ständigt
      mata in ny data eller modifiera data. Risken för oregelbunden json objekt
      blir stor. Så det underlättar att få dummyDecks genererad.
    </p>
    <details>
      <summary>Visa kod för: src/stores/flashcards.js</summary>
      <pre class="hljs"><code><div>actions: {
    createCard(title, question = <span class="hljs-string">""</span>, answer) {
      <span class="hljs-keyword">return</span> {
        title,
        question,
        answer,
        <span class="hljs-attr">needsPractice</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">id</span>: uuidv4(),
      };
    },
    addToDeck(card, deckId) {
      <span class="hljs-keyword">const</span> deck = <span class="hljs-keyword">this</span>.decks.filter(<span class="hljs-function">(<span class="hljs-params">deck</span>) =&gt;</span> deck.id === deckId);
      deck[<span class="hljs-number">0</span>].cards.push(card);
    },
    createDeck(title, cards = []) {
      <span class="hljs-keyword">const</span> deck = {
        title,
        cards,
        <span class="hljs-attr">id</span>: uuidv4(),
      };
      <span class="hljs-keyword">this</span>.decks.push(deck);
      <span class="hljs-keyword">return</span> deck.id;
    },
    <span class="hljs-comment">/**Genrates multiplication table from 1-12 and adds to this.decks */</span>
    dummyDeck() {
      <span class="hljs-keyword">const</span> tableAmounts = <span class="hljs-number">10</span>;
      <span class="hljs-keyword">const</span> tableLimit = <span class="hljs-number">12</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>; x &lt;= tableAmounts; x++) {
        <span class="hljs-keyword">const</span> deckTitle = <span class="hljs-string">`<span class="hljs-subst">${x}</span>:ans gånger tabell`</span>;
        <span class="hljs-keyword">const</span> deckId = <span class="hljs-keyword">this</span>.createDeck(deckTitle);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">1</span>; y &lt;= tableLimit; y++) {
          <span class="hljs-keyword">const</span> title = <span class="hljs-string">`<span class="hljs-subst">${x}</span> x <span class="hljs-subst">${y}</span> = ?`</span>;
          <span class="hljs-keyword">const</span> answer = x * y;
          <span class="hljs-keyword">const</span> card = <span class="hljs-keyword">this</span>.createCard(title, <span class="hljs-string">""</span>, answer);
          <span class="hljs-keyword">this</span>.addToDeck(card, deckId);
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.decks;
    },
  }
</div></code></pre>
    </details>
    <hr />
    <h2 id="2402-25">24/02-25</h2>
    <h3 id="cardcounter">Cardcounter</h3>
    <p>
      Jag ville att användaren ska kunna se hur långt in bland sina kort den
      tagit sig, så idag implementerade jag en cardcounter, väldigt simpel
      lösning. Utifrån url:n tar sidan fram actuell korlek för att räkna ut hur
      många kort som finns i kortleken och sätta in det som ett maxvärde i
      countern, samt hämtar cardIndex från url:n och visar ut vilket index
      användaren befinner sig på
      <br />
      <br />
      Ett problem jag märkte var att användaren kunde navigera sig ur kortlekens
      max-kortantal. Så med hjälp av if conditions kollade jag så användaren
      höll sig inom kortlekens längd. knapparna ska inte navigera över eller för
      under kortantal.
    </p>
    <details>
      <summary>Visa kod för: src/view/CollectionView.vue</summary>
      <pre class="hljs"><code><div><span class="hljs-comment">// script</span>

<span class="hljs-comment">// Variables for count</span>
<span class="hljs-keyword">const</span> cardIndex = ref(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> cardAmount = ref(<span class="hljs-number">0</span>);

watchEffect(
  <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> [route.params.deckId, route.params.cardNr],
  updateCurrentCard(route.params.deckId - <span class="hljs-number">1</span>, route.params.cardNr - <span class="hljs-number">1</span>),
);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCurrentCard</span>(<span class="hljs-params">deckId, cardIndex</span>) </span>{
  currentDeck.value = flashcard.decks[deckId];
  currentCard.value = currentDeck.value.cards[cardIndex];
  updateCount(flashcard.decks[deckId], cardIndex);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCount</span>(<span class="hljs-params">deck, cardNumber</span>) </span>{
  cardAmount.value = deck.cards.length;
  cardIndex.value = cardNumber + <span class="hljs-number">1</span>;
}

<span class="hljs-comment">// template</span>
&lt;div v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"hideAnswer"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"card"</span> id=<span class="hljs-string">"front"</span>&gt;
  {{ currentCard.question }}
  &lt;span id=<span class="hljs-string">"count"</span>&gt;{{ cardIndex }}/{{ cardAmount }}&lt;<span class="hljs-regexp">/span&gt;
&lt;/</span>div&gt;
</div></code></pre>
    </details>
    <hr />
    <p><img src="images/image-1.png" alt="alt text" /></p>
    <p><img src="images/image.png" alt="card count flashcard" /></p>
    <h2 id="2502-25">25/02-25</h2>
    <h3 id="utmanande-framg%C3%A5ng">Utmanande framgång</h3>
    <p>
      Jag tyckte min kod var rätt så elegant och smart som lösning för hantering
      av våra flashcardsfunktioner, dock insåg jag sen att det blev en krock med
      teamet iochmed att dom inte suttit sig in i pinia på samma nivå. Så där
      blev det utmanande att integrera kod med varrandra. Som lösning på det
      skapade jag en .json fil för dummyjson så lagmedlemmarna kunde berabeta
      den som om det vore en api fetch. Där jag basicly kompierade objectet som
      dummyDeck() spottatde ut och klistrade in i en .json fil.
    </p>
    <h3 id="navigering-inom-korlek">Navigering inom korlek</h3>
    <p>
      Simon lade till pilarna som console loggade (previous) och (next), Jag och
      Zaher parprogrammerade fram funtionalliteten till pilarna så dom rör
      användaren bak eller fram i den aktuella kortleken. Eftersom jag tidigare
      designat att det är url:n som bestämmer vilket kort som ska visas var det
      väldigt enkelt att komma på en lösning, det var bara att plussa på eller
      subdrahera kort indexet i url:n för att navigera framm eller tillbaks.
    </p>
    <details>
      <summary>Visa kod för: src/view/CardView.vue</summary>
      <pre class="hljs"><code><div>&lt;script setup&gt;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">goPrevious</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (cardNr.value &gt; <span class="hljs-number">1</span>) {
    cardNr.value--;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">goNext</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> cardAmount = currentDeck.value.cards.length
  <span class="hljs-keyword">if</span> (cardNr.value &lt; cardAmount) {
    cardNr.value++;
  }
}

&lt;<span class="hljs-regexp">/script&gt;


&lt;template&gt;
  &lt;div class="flashcard"&gt;
    &lt;router-link :to="`${cardNr}`"&gt;
      &lt;button class="arrow" @click="goPrevious"&gt;⬅️&lt;/</span>button&gt;
    &lt;<span class="hljs-regexp">/router-link&gt;

    &lt;FlashCard @on-deck-update="updateDeck" /</span>&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"`${cardNr}`"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"arrow"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"goNext"</span>&gt;</span>➡️<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span>
  &lt;<span class="hljs-regexp">/div&gt;
&lt;/</span>template&gt;
</div></code></pre>
    </details>
    <hr />
    <p>
      <img
        src="images/flashcard-med-navigersinspilar.png"
        alt="flashcard med navigersinspilar"
      />
    </p>
    <h3 id="avsl%C3%B6jar-svar-f%C3%B6r-tidigt-bugg">
      Avslöjar svar för tidigt bugg
    </h3>
    <p>
      Efter att ha löst navigering mellan kort dök det upp en bugg. När
      användaren visar svaret så syns svaret och när man då byter till nästa
      kort så förväntas det att man får en ny fråga. Men då dök nästa kort upp
      med svaret uppåt istället för frågan, detta berodde på att variablen
      hideAnswer=false ej ändrades tillbaka till true vid kortnavigation. Efter
      mycket om och men kom jag fram till en pinsamt enkel lösning. Så fort
      url:n uppdateras ska hideAnswer sättas till true.
    </p>
    <details>
      <summary>Visa kod för: src/components/FlashCard.vue</summary>
      <pre
        class="hljs"
      ><code><div><span class="hljs-comment">// Update deckId and cardId when url changes</span>
onBeforeRouteUpdate(<span class="hljs-keyword">async</span> (to, <span class="hljs-keyword">from</span>) =&gt; {
  <span class="hljs-comment">// Hides answer when player press next or previous button</span>
  hideAnswer.value = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">const</span> deckId = to.params.deckId - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">const</span> cardNr = to.params.cardNr - <span class="hljs-number">1</span>;
  updateCurrentCard(deckId, cardNr);

  <span class="hljs-comment">// Send current deck to parrent</span>
  emit(<span class="hljs-string">"on-deck-update"</span>, currentDeck.value);
});
</div></code></pre>
    </details>
    <hr />
    <h2 id="2602-25">26/02-25</h2>
    <h3 id="svars-indikator">Svars-indikator</h3>
    <p>
      Vi kom fram till att användaren ska kunna se sin statestik när alla svar
      är besvarade. Så vi behövde ett sätt för användaren att kunna få en tydlig
      överblick över vilka kort den svarat på och om användaren svarat rätt/fel.
      Så kom på iden att skapa lika många prickar som antal kort i leken.
      pricken är grå om kortet saknar svar och röd eller grön om den är
      besvarad. Alltså får ingen prick vara grå för att användaren ska få se sin
      statestik.
    </p>
    <p><img src="images/answer-indicator.gif" alt="svars indicator" /></p>
    <p>
      Utmaningen var att ge den aktuella &quot;pricken&quot; correkt css,
      antingen ska den vara:
    </p>
    <ul>
      <li>Röd [Om man svarat fel]</li>
      <li>Grön [Om man svarat rätt]</li>
      <li>Grå [Om man inte svarat alls]</li>
      <li>
        Stor [På den prick som har samma index som det kort man befinner sig på]
      </li>
    </ul>
    <p>
      Detta löste jag med hjälp av funktionen dotStyle(currentCard) som kollar
      av de olika vilkoren av akuella kortet som har boolean värden hasAnswer
      och needsPractice. Slutningsvis skapar den en sträng som består av de css
      classer pricken ska ha.
    </p>
    <details>
      <summary>Visa kod för: src/view/CardView.vue</summary>
      <pre class="hljs"><code><div><span class="hljs-comment">// Script</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dotStyle</span>(<span class="hljs-params">currentCard</span>) </span>{
  <span class="hljs-keyword">const</span> cardIndex = <span class="hljs-number">1</span> + currentDeck.value.cards.indexOf(currentCard);
  <span class="hljs-keyword">let</span> styleSettings = <span class="hljs-string">"dot "</span>;
  watchEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> cardNr = <span class="hljs-built_in">parseInt</span>(route.params.cardNr);
    <span class="hljs-keyword">if</span> (cardIndex === cardNr) {
      styleSettings += <span class="hljs-string">"current "</span>;
    }
  });
  <span class="hljs-keyword">if</span> (currentCard.hasAnswer &amp;&amp; !currentCard.needsPractice) {
    styleSettings += <span class="hljs-string">"correct "</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentCard.hasAnswer &amp;&amp; currentCard.needsPractice) {
    styleSettings += <span class="hljs-string">"wrong "</span>;
  }
  <span class="hljs-keyword">return</span> styleSettings;
}

<span class="hljs-comment">// Template</span>
&lt;div id=<span class="hljs-string">"answer-indicator"</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
    <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(card) in currentDeck.cards"</span>
    <span class="hljs-attr">:key</span>=<span class="hljs-string">"card.id"</span>
    <span class="hljs-attr">:class</span>=<span class="hljs-string">"dotStyle(card)"</span>
  /&gt;</span></span>
&lt;<span class="hljs-regexp">/div&gt;

/</span><span class="hljs-regexp">/ style
.dot {
  height: 10px;
  width: 10px;
  background-color: #adadad;
  border-radius: 100px;
}

.current {
  width: 15px;
  height: 15px;
}
.correct {
  /</span>* background-color: #<span class="hljs-number">47973</span>e; *<span class="hljs-regexp">/
  background-color: var(--success);
}
.wrong {
  background-color: #973e3e;
  background-color: var(--danger);
}

</span></div></code></pre>
    </details>
    <hr />
    <h2 id="01---0303-25---statistik-sida">01 - 03/03-25 - Statistik sida</h2>
    <h3 id="statistik-sida">Statistik sida</h3>
    <p>
      Vi vill ha en sida där användaren kan få en överblick över användarens
      prestation utvecklats tack vare vår flashcard tjänst. Målet är att sidan
      ska göra det motiverande för användaren att fortsätta träna tills
      kunskapen sitter.
      <br />
      Största utmaningen här var att veta vad för statistik som är relevant för
      användaren, och att få allting responsivt och se bra ut på telefon och
      desktop. är 90% nöjd.
      <br />
      Jag insåg att när jag var klar med allt så kände jag att det saknades
      något. Ett sätt att från denna sida ta sig till respektive kortlek och
      starta en session. Iochmed att jag inte haft med det i kalkylen, hade jag
      svårt att bestämma mig för vart jag skulle placera en sån knapp eller
      länk. Så den trycktes mest in där den fick plats. Det jag kunde gjort
      bättre var att bygga sidan mer skalbar, så den inte är lika känslig ifall
      man skulle vilja lägga till saker i efterhand.
      <br />
      <br />
      Elin ansvarar för knapparnas funktionallitet, innan dom är klara så måste
      jag simulera en användares olika &quot;tränings sessioner&quot; så jag
      skissade först upp vad jag vill att användaren ska se på sidan, sen
      skapade jag funktioner som genererar dummy data så jag har någonting att
      bygga runt. I framtiden kommer sessioner skapas för varje gång en
      användare genomfört en kort träning.
      <br />
      Innan jag går in på kod, kommer en treat på den färdiga statistics sidan
    </p>
    <p><img src="images/statistic-view.gif" alt="statistik vy" /></p>
    <h3 id="det-vi-ser-p%C3%A5-sidan-%C3%A4r">Det vi ser på sidan är</h3>
    <ul>
      <li>Kortlekens titel</li>
      <li>En dirrektlänk till kortlek ifall man vill öva dirrekt.</li>
      <li>
        Ett prickdiagram som visar en historisk överblick för 10 senast
        sessioner
      </li>
      <li>
        Totala genomsnittet, senaste sessionens genomsnitt och antal gånger man
        tränat. Färgen baseras på hur höga siffrorna är och går från rött, gult,
        grönt
      </li>
      <li>
        Ett av det korten vi har lättast för, och ett av de kort vi har svårast
        för, dessa tas fram genom att jämföra de två senaste sessionerna och om
        man svarat rätt två gånger per rad så utnämns det kortet som ett kort
        man kan, vise versa för det kort man har problem med, svara fel två
        gånger per rad anses det vara ett kort man har extra problem med
      </li>
      <li>
        Lista på alla kortlekar man har sparade så man smidigt kan navigera och
        få överblicka de lekar man vill.
      </li>
    </ul>
    <hr />
    <h3 id="kod-som-simulerar-data">Kod som simulerar data</h3>
    <p>
      dummySessions, sessionRange och cardRange är nya variabler. Detta för att
      smidigt kunna tweaka data för att debugga beroende på hur mycket data som
      finns etc, tex hur löser jag responsiviteten för en användare som skapar
      20+ sessioner jämfört med en som bara har 2 sessioner.
      <br />
      Det var utmamande att lista ut hur man sparar data för att kunna ta fram
      statistiken. Jag kom fram till att det bästa vore om man kan spara en
      session som en &quot;snapshot&quot; som index i en array, sen utifrån alla
      session arrayer jämföra dom med varrandra för att få fram önskad
      information.
    </p>
    <details>
      <summary>Visa kod för: src/stores/flashcards.js</summary>
      <h3 id="debug-variabler-f%C3%B6r-flashcardsjs">
        Debug variabler för flashcards.js
      </h3>
      <pre
        class="hljs"
      ><code><div>state: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    <span class="hljs-comment">/** The global variable that contains all current user decks*/</span>
    <span class="hljs-attr">decks</span>: [],
    <span class="hljs-attr">dummySessions</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// fill sessions with dummysessions</span>
    <span class="hljs-attr">sessionsRange</span>: { <span class="hljs-attr">start</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">end</span>: <span class="hljs-number">20</span> }, <span class="hljs-comment">// generates between start to end amounts of sessions</span>
    <span class="hljs-attr">cardRange</span>: { <span class="hljs-attr">start</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">end</span>: <span class="hljs-number">20</span> } <span class="hljs-comment">// generates between start to end amounts of cards when creating deck</span>
  }),
</div></code></pre>
      <h3 id="createdecktitle-cards">createDeck(title, cards)</h3>
      <p>
        Jag valde att spara kortlekens sessioner tillsammans med kortleken i
        nyckeln &quot;stats&quot;, där sessions kommer innehålla korlekens
        historiska sessioner
      </p>
      <pre
        class="hljs"
      ><code><div><span class="hljs-comment">/** Creates a deck from array of cards with title
     * <span class="hljs-doctag">@param <span class="hljs-type">{String}</span> </span>title The name of the deck
     * <span class="hljs-doctag">@param <span class="hljs-type">{Array}</span> </span>cards Array of card objects
     * <span class="hljs-doctag">@returns </span>deck object.
     */</span>
    createDeck(title, cards = []) {
      <span class="hljs-keyword">const</span> deck = {
        title,
        cards,
        <span class="hljs-attr">id</span>: uuidv4(),
        <span class="hljs-attr">stats</span>: {
          <span class="hljs-attr">average</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// Total average score 1-100%</span>
          <span class="hljs-attr">mastered</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// mastered cards</span>
          <span class="hljs-attr">practice</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// cards need practice</span>
          <span class="hljs-attr">latest</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// latest score 1-100%</span>
          <span class="hljs-attr">practiceAmount</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// total practice amount</span>
          <span class="hljs-attr">sessions</span>: [] <span class="hljs-comment">// use sessions data to declare rest of stats</span>
        }
      };
      <span class="hljs-comment">// this.decks.push(deck);</span>
      <span class="hljs-keyword">return</span> deck;
    }

</div></code></pre>
      <h3 id="filldummydatadeck">fillDummyData(deck)</h3>
      <p>
        Tar emot en befintlig kortlek och börjar med att fylla ut
        <strong>deck.stats.sessions</strong> med slumpmässig data. Resterande
        funktioner är baserade på att sessions innehåller data. Mer om de längre
        fram.
      </p>
      <pre
        class="hljs"
      ><code><div><span class="hljs-comment">/** fill deck.stats with information using stats.sessions data
 * <span class="hljs-doctag">@param <span class="hljs-type">{Object}</span> </span>deck deck object from createDeck()
 */</span>
fillDummyData(deck) {
  <span class="hljs-keyword">this</span>.fillDummySessions(
    deck,
    <span class="hljs-keyword">this</span>.random(<span class="hljs-keyword">this</span>.sessionsRange.start, <span class="hljs-keyword">this</span>.sessionsRange.end)
  );
  deck.stats.practice = <span class="hljs-keyword">this</span>.getFlashcardsByStatus(deck, <span class="hljs-string">"practice"</span>);
  deck.stats.mastered = <span class="hljs-keyword">this</span>.getFlashcardsByStatus(deck, <span class="hljs-string">"mastered"</span>);
  deck.stats.practiceAmount = deck.stats.sessions.length;
  deck.stats.latest = <span class="hljs-keyword">this</span>.getSessionAverage(
    deck.stats.sessions.slice(<span class="hljs-number">-1</span>)[<span class="hljs-number">0</span>] <span class="hljs-comment">// Get average from last session</span>
  );
  deck.stats.average = <span class="hljs-keyword">this</span>.getTotalAverage(deck.stats.sessions);
}

</div></code></pre>
      <h3 id="filldummysessiondeck">fillDummySession(deck)</h3>
      <p>
        Tar emot en lek och ett amount värde. Här går jag igenom varje kort och
        gör att:
      </p>
      <ul>
        <li>needsPractive = true 25% av svaren och true 75%</li>
        <li>
          hasAnswer = true (eftersom det krävs att alla frågor har ett svar för
          att kunna skapa en session)
        </li>
      </ul>
      <pre
        class="hljs"
      ><code><div><span class="hljs-comment">/** Fill deck.stat.sessions with given amount of random sessions
 * <span class="hljs-doctag">@param <span class="hljs-type">{Object}</span> </span>deck deck object from createDeck()
 * <span class="hljs-doctag">@param <span class="hljs-type">{Number}</span> </span>amount amount of dummy session to generate
 */</span>
fillDummySessions(deck, amount) {
  <span class="hljs-keyword">const</span> cards = deck.cards;
  <span class="hljs-keyword">let</span> sessions = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; amount; index++) {
    <span class="hljs-keyword">let</span> session = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> card <span class="hljs-keyword">of</span> cards) {
      <span class="hljs-keyword">const</span> cardCopy = { ...card }; <span class="hljs-comment">// duplicate card, otherwise all sessions ends up looking the same</span>
      cardCopy.hasAnswer = <span class="hljs-literal">true</span>;
      <span class="hljs-comment">// 25% to answer wrong</span>
      cardCopy.needsPractice =
        <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">4</span>) + <span class="hljs-number">1</span> === <span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
      session.push(cardCopy);
    }
    sessions.push(session);
  }
  deck.stats.sessions = sessions;
}
</div></code></pre>
      <h3 id="getflashcardsbystatusdeck">getFlashcardsByStatus(deck)</h3>
      <p>
        Spottar ut kort som antingen är bemästrade eller behöver övning. Från
        början skapade jag två sepparata funktioner för detta ändamål, men insåg
        att koden ser exakt likadan ut, så bakade in ett vilkor som avgör vilket
        funktionen spottar ut.
      </p>
      <p>
        Funktionen jämför de två senaste sessioner (standardsiffra) och kollar
        om det finns en streak i någon form, om korten fick samma svar så sparas
        de i en array och skickas ut.
      </p>
      <pre
        class="hljs"
      ><code><div><span class="hljs-comment">/** Returns either the cards that needs practice or cards that are masterd from latest sessions
 *
 * <span class="hljs-doctag">@param <span class="hljs-type">{Object}</span> </span>deck from createDeck()
 * <span class="hljs-doctag">@param <span class="hljs-type">{String}</span> </span>status practice / mastered
 * <span class="hljs-doctag">@param <span class="hljs-type">{Number}</span> </span>latestSessionAmount if latestSessionAmount = 2 it will only compare the last two sessions
 * <span class="hljs-doctag">@returns </span>Card array of either mastered or cards that needs practice
 */</span>
getFlashcardsByStatus(deck, status = <span class="hljs-string">"practice"</span>, latestSessionAmount = <span class="hljs-number">2</span>) {
  <span class="hljs-comment">// Fill masteredCardIds with all card ids, then remove id if card dont need pracice</span>
  <span class="hljs-keyword">let</span> flashcardIds = deck.cards.map(<span class="hljs-function">(<span class="hljs-params">card</span>) =&gt;</span> card.id);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> session <span class="hljs-keyword">of</span> deck.stats.sessions.slice(
    latestSessionAmount * <span class="hljs-number">-1</span>
  )) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> card <span class="hljs-keyword">of</span> session) {
      <span class="hljs-keyword">if</span> (status === <span class="hljs-string">"practice"</span>) {
        <span class="hljs-keyword">if</span> (!card.needsPractice) {
          flashcardIds = flashcardIds.filter(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> id != card.id);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status === <span class="hljs-string">"mastered"</span>) {
        <span class="hljs-keyword">if</span> (card.needsPractice) {
          flashcardIds = flashcardIds.filter(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> id != card.id);
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
          <span class="hljs-string">`status has to be either practice or mastered not: <span class="hljs-subst">${status}</span> `</span>
        );
      }
    }
  }

  flashcardIds = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(flashcardIds); <span class="hljs-comment">// Remove duplicate ids</span>
  <span class="hljs-comment">// retrive cards with ids from needsPractice</span>
  <span class="hljs-keyword">let</span> filteredCards = [];

  <span class="hljs-comment">// save cards with ids from masteredCardIds to array</span>
  <span class="hljs-built_in">Array</span>.from(flashcardIds).map(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {
    deck.cards.filter(<span class="hljs-function">(<span class="hljs-params">card</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (card.id === id) {
        filteredCards.push(card);
      }
    });
  });

  <span class="hljs-keyword">return</span> filteredCards;
}

</div></code></pre>
      <h3 id="getsessionaveragedeck">getSessionAverage(deck)</h3>
      <p>
        Tar fram genomsnittsvärdet en specifik sessione och retunerar det som
        ett procentvärde. Jag gjorde funktionen för att jag sen ska kunna
        iterera genom alla sessioner och använda denna funktion för att få det
        totala snittvärdet.
      </p>
      <pre
        class="hljs"
      ><code><div><span class="hljs-comment">/**Get sessions average score
 *
 * <span class="hljs-doctag">@param <span class="hljs-type">{Array}</span> </span>session array of cards with data from a session
 * <span class="hljs-doctag">@returns </span>average precentage score from session
 */</span>
getSessionAverage(session) {
  <span class="hljs-keyword">let</span> questions = session.length;
  <span class="hljs-keyword">let</span> score = <span class="hljs-number">0</span>;
  session.forEach(<span class="hljs-function">(<span class="hljs-params">card</span>) =&gt;</span> {
    score += card.needsPractice ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;
  });
  <span class="hljs-keyword">let</span> average = (score / questions) * <span class="hljs-number">100</span>;
  <span class="hljs-keyword">return</span> average.toFixed();
}

</div></code></pre>
      <h3 id="gettotalaveragedeck">getTotalAverage(deck)</h3>
      <p>
        Här använder jag mig av getSessionAverage för att räkna samman
        kortlekens totala snittvärde.
      </p>
      <pre
        class="hljs"
      ><code><div><span class="hljs-comment">/** Get total average score from multiple sessions
 *
 * <span class="hljs-doctag">@param <span class="hljs-type">{Array}</span> </span>sessions Array containng multiple sessions
 * <span class="hljs-doctag">@returns </span>average precentage score from all sessions
 */</span>
getTotalAverage(sessions) {
  <span class="hljs-keyword">let</span> score = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> session <span class="hljs-keyword">of</span> sessions) {
    score += <span class="hljs-built_in">Number</span>(<span class="hljs-keyword">this</span>.getSessionAverage(session));
  }
  <span class="hljs-keyword">return</span> (score / sessions.length).toFixed();
}

</div></code></pre>
    </details>
    <hr />
    <h3 id="statisticsviewvue">StatisticsView.vue</h3>
    <p>StatisticsView inehåller:</p>
    <ul>
      <li>
        En komponent för kortlekens statestik, därför skickar jag in en kortlek
        som en prop
      </li>
      <li>Lista över alla korlekar som finns</li>
    </ul>
    <details>
      <summary>Visa kod för: src/view/StatisticsView.vue</summary>
      <pre class="hljs"><code><div><span class="hljs-comment">// Script</span>
&lt;script setup&gt;
  <span class="hljs-keyword">import</span> { useFlashcard } <span class="hljs-keyword">from</span> <span class="hljs-string">"../stores/flashcards"</span>;
  <span class="hljs-keyword">import</span> { ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;
  <span class="hljs-keyword">import</span> { useRoute } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue-router"</span>;
  <span class="hljs-keyword">import</span> DeckStats <span class="hljs-keyword">from</span> <span class="hljs-string">"../components/DeckStats.vue"</span>;

  <span class="hljs-keyword">const</span> flashcard = useFlashcard();
  <span class="hljs-keyword">const</span> decks = ref(flashcard.decks);
  <span class="hljs-keyword">const</span> route = useRoute();
&lt;<span class="hljs-regexp">/script&gt;

/</span><span class="hljs-regexp">/ Template
template&gt;
  &lt;main&gt;
    &lt;!-- Picks deck from decks array by targeting index retrived from url (route.params.deckId) --&gt;
    &lt;DeckStats :deck="flashcard.decks[route.params.deckId - 1]" /</span>&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- Links to targeted deck by directing to decks index from url --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"nodeco"</span>
        <span class="hljs-attr">v-for</span>=<span class="hljs-string">"deck in decks"</span>
        <span class="hljs-attr">:key</span>=<span class="hljs-string">"deck.id"</span>
        <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/statistics/' + Number(decks.indexOf(deck) + 1)"</span>
      &gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{{ deck.title }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
  &lt;<span class="hljs-regexp">/main&gt;
&lt;/</span>template&gt;

</div></code></pre>
    </details>
    <hr />
    <h3 id="deckstatsvue">DeckStats.vue</h3>
    <p>DeckStats har ett gridsystem som inehåller:</p>
    <ul>
      <li>
        Title
        <ul>
          <li>Kortleks titeln</li>
          <li>Länk till kortlek</li>
          <li>prickgraph</li>
        </ul>
      </li>
      <li>
        Info
        <ul>
          <li>average</li>
          <li>latest average</li>
          <li>practice amount</li>
        </ul>
      </li>
      <li>
        Cards
        <ul>
          <li>kort som bemästrats (om finns)</li>
          <li>kort som är extra utmanande (om finns)</li>
        </ul>
      </li>
    </ul>
    <p>
      Jag ville att info värderna skulle infinna sig i en cirkel där bordern och
      textfärgen är samma färg och bakgrundsfärgen är samma färg men med en
      opacity på 27%. Men färgerna ska varierar beroende på prestanda
    </p>
    <ul>
      <li>Average | rött &lt; 50; gult &lt; 75 grönt +75</li>
      <li>Latest average | rött &lt; 50; gult &lt; 75 grönt +75</li>
      <li>
        Times | rött &lt; 5; gult &lt; 10 grönt + 10 Jag löste detta med hjälp
        av css variabler som jag sen med v-bind kunde manipulera, vilket syns
        senare i template
      </li>
    </ul>
    <details>
      <summary>visa .stat i components/DeckStats.vue</summary>
      <pre
        class="hljs"
      ><code><div><span class="hljs-selector-class">.stat</span> {
  <span class="hljs-comment">/* class for statistic info (average, latest average, times) */</span>
  <span class="hljs-comment">/* Standard color are yellow, change rbg with :style="" in element to set customised color */</span>
  <span class="hljs-attribute">--r</span>: <span class="hljs-number">172</span>;
  <span class="hljs-attribute">--b</span>: <span class="hljs-number">91</span>;
  <span class="hljs-attribute">--g</span>: <span class="hljs-number">44</span>;
  <span class="hljs-attribute">--color</span>: <span class="hljs-built_in">rgb</span>(var(--r), <span class="hljs-built_in">var</span>(--b), <span class="hljs-built_in">var</span>(--g));
  <span class="hljs-attribute">--color-o</span>: <span class="hljs-built_in">rgb</span>(var(--r), <span class="hljs-built_in">var</span>(--b), <span class="hljs-built_in">var</span>(--g), <span class="hljs-number">27%</span>);
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">grid-area</span>: stat;
  <span class="hljs-attribute">font-weight</span>: bold;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">justify-content</span>: center;
  <span class="hljs-attribute">align-items</span>: center;
  <span class="hljs-attribute">width</span>: <span class="hljs-built_in">clamp</span>(<span class="hljs-number">13vw</span>, <span class="hljs-number">5em</span>, <span class="hljs-number">6em</span>);
  <span class="hljs-attribute">height</span>: <span class="hljs-built_in">clamp</span>(<span class="hljs-number">13vw</span>, <span class="hljs-number">13vw</span>, <span class="hljs-number">15px</span>);
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--color-o);
  <span class="hljs-attribute">border</span>: double <span class="hljs-number">0.4em</span> <span class="hljs-built_in">var</span>(--color);
  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--color);
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">1000px</span>;
}
</div></code></pre>
    </details>
    <hr />
    <h3 id="script-och-template">Script och template</h3>
    <ul>
      <li>
        I script har jag deklarerat färger som .stats sen ska stilsättas med
        beroende på värde.
      </li>
      <li>
        Template inehåller ritar ut allt med hjälp av dummy datan som genererats
        i flashcard.js
      </li>
    </ul>
    <details>
      <summary>
        Visa script och template för: src/components/DeckStats.vue.vue
      </summary>
      <pre class="hljs"><code><div><span class="hljs-comment">// Script</span>
&lt;script setup&gt;
  <span class="hljs-keyword">import</span> { useFlashcard } <span class="hljs-keyword">from</span> <span class="hljs-string">"../stores/flashcards"</span>;
  <span class="hljs-keyword">import</span> { defineProps, ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;
  <span class="hljs-keyword">import</span> { useRoute } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue-router"</span>;
  <span class="hljs-keyword">const</span> flashcard = useFlashcard();

  <span class="hljs-comment">// css variables r, b, g to give stat circles color depending on stat score</span>
  <span class="hljs-keyword">const</span> red = ref({ <span class="hljs-string">"--r"</span>: <span class="hljs-number">175</span>, <span class="hljs-string">"--b"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"--g"</span>: <span class="hljs-number">1</span> });
  <span class="hljs-keyword">const</span> green = ref({ <span class="hljs-string">"--r"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"--b"</span>: <span class="hljs-number">143</span>, <span class="hljs-string">"--g"</span>: <span class="hljs-number">0</span> });
  <span class="hljs-keyword">const</span> yellow = ref({ <span class="hljs-string">"--r"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"--b"</span>: <span class="hljs-number">143</span>, <span class="hljs-string">"--g"</span>: <span class="hljs-number">0</span> });
  <span class="hljs-keyword">const</span> route = useRoute();

  <span class="hljs-keyword">const</span> sessions = ref();

  <span class="hljs-keyword">const</span> props = defineProps({
    <span class="hljs-attr">deck</span>: {
      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Object</span>
    }
  });

  <span class="hljs-comment">// Let dot graph max show 10 latest sessions</span>
  <span class="hljs-keyword">let</span> dotsGraph =
    props.deck.stats.sessions.length &lt; <span class="hljs-number">10</span>
      ? props.deck.stats.sessions
      : props.deck.stats.sessions.slice(<span class="hljs-number">-10</span>);

  <span class="hljs-comment">// Update dotgraph to current decks sessions when url changes</span>
  watch(
    <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> route.params.deckId,
    (newId, oldId) =&gt; {
      sessions.value = flashcard.decks[newId - <span class="hljs-number">1</span>].stats.sessions;
      <span class="hljs-comment">// Let dot graph max show 10 latest sessions</span>
      dotsGraph =
        sessions.value.length &lt; <span class="hljs-number">10</span> ? sessions.value : sessions.value.slice(<span class="hljs-number">-10</span>);
    }
  );
&lt;<span class="hljs-regexp">/script&gt;

/</span><span class="hljs-regexp">/ Template
&lt;template&gt;
  &lt;section&gt;
    &lt;div id="title"&gt;
      &lt;h1&gt;
        {{ deck.title }}
      &lt;/</span>h1&gt;
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span>
        <span class="hljs-attr">id</span>=<span class="hljs-string">"practice-link"</span>
        <span class="hljs-attr">:to</span>=<span class="hljs-string">"`/collection/${route.params.deckId}/1`"</span>
        &gt;</span>Practice this deck<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>
      &gt;</span>
      <span class="hljs-comment">&lt;!-- Draws out all sesssion history where a card answer represent a dot red or green  --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dots-container"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"deck.stats.sessions"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"!deck.stats.sessions[0]"</span>&gt;</span>Study this deck to gather data<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"session in dotsGraph"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"session.id"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"dots"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"card in session"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"card.id"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"card.hasAnswer &amp;&amp; card.needsPractice"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"dot red"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
              <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"card.hasAnswer &amp;&amp; !card.needsPractice"</span>
              <span class="hljs-attr">class</span>=<span class="hljs-string">"dot green"</span>
            /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"dot grey"</span> /&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    &lt;!-- Displays three circles average, latest session and amount <span class="hljs-keyword">of</span> tries,
     circles color turns either red, yellow or green depending on score--&gt;

    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"info"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"deck.stats.sessions[0]"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- Average: red when score &lt; 50, yellow: score &lt; 75, else green --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stat-title"</span>&gt;</span>Average<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stat"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"deck.stats.average &lt; 50"</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"red"</span>&gt;</span>
            {{ deck.stats.average }}%
          <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stat"</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"deck.stats.average &gt;= 75"</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"green"</span>&gt;</span>
            {{ deck.stats.average }}%
          <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stat"</span> <span class="hljs-attr">v-else</span>&gt;</span>{{ deck.stats.average }}%<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Latest session score: red when score &lt; 50, yellow: score &lt; 75, else green --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stat-title"</span>&gt;</span>Latest<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stat"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"deck.stats.latest &lt; 50"</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"red"</span>&gt;</span>
            {{ deck.stats.latest }}%
          <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stat"</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"deck.stats.latest &gt;= 75"</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"green"</span>&gt;</span>
            {{ deck.stats.latest }}%
          <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stat"</span> <span class="hljs-attr">v-else</span>&gt;</span>{{ deck.stats.latest }}%<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Tries: red when score &lt; 5, yellow: score &lt; 10, else green --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stat-title"</span>&gt;</span>Tries<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stat"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"deck.stats.practiceAmount &lt; 5"</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"red"</span>&gt;</span>
            x{{ deck.stats.practiceAmount }}
          <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>
            <span class="hljs-attr">class</span>=<span class="hljs-string">"stat"</span>
            <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"deck.stats.practiceAmount &gt; 10"</span>
            <span class="hljs-attr">:style</span>=<span class="hljs-string">"green"</span>
          &gt;</span>
            x{{ deck.stats.practiceAmount }}
          <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stat"</span> <span class="hljs-attr">v-else</span>&gt;</span>x{{ deck.stats.practiceAmount }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    &lt;!-- Displays one <span class="hljs-keyword">of</span> players mastered card one <span class="hljs-keyword">of</span> players toughest card --&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cards"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"deck.stats.sessions[0]"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"deck.stats.mastered[0]"</span>&gt;</span>
        {{ deck.stats.mastered[0].question }}
        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span>
          <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span>
          <span class="hljs-attr">width</span>=<span class="hljs-string">"50"</span>
          <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span>
          <span class="hljs-attr">fill</span>=<span class="hljs-string">"currentColor"</span>
          <span class="hljs-attr">class</span>=<span class="hljs-string">"bi bi-hand-thumbs-up-fill stamp thumbs-up"</span>
          <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 16 16"</span>
        &gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
            <span class="hljs-attr">d</span>=<span class="hljs-string">"M6.956 1.745C7.021.81 7.908.087 8.864.325l.261.066c.463.116.874.456 1.012.965.22.816.533 2.511.062 4.51a10 10 0 0 1 .443-.051c.713-.065 1.669-.072 2.516.21.518.173.994.681 1.2 1.273.184.532.16 1.162-.234 1.733q.086.18.138.363c.077.27.113.567.113.856s-.036.586-.113.856c-.039.135-.09.273-.16.404.169.387.107.819-.003 1.148a3.2 3.2 0 0 1-.488.901c.054.152.076.312.076.465 0 .305-.089.625-.253.912C13.1 15.522 12.437 16 11.5 16H8c-.605 0-1.07-.081-1.466-.218a4.8 4.8 0 0 1-.97-.484l-.048-.03c-.504-.307-.999-.609-2.068-.722C2.682 14.464 2 13.846 2 13V9c0-.85.685-1.432 1.357-1.615.849-.232 1.574-.787 2.132-1.41.56-.627.914-1.28 1.039-1.639.199-.575.356-1.539.428-2.59z"</span>
          /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"deck.stats.practice[0]"</span>&gt;</span>
        {{ deck.stats.practice[0].question }}
        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span>
          <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span>
          <span class="hljs-attr">width</span>=<span class="hljs-string">"50"</span>
          <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span>
          <span class="hljs-attr">fill</span>=<span class="hljs-string">"currentColor"</span>
          <span class="hljs-attr">class</span>=<span class="hljs-string">"bi bi-hand-thumbs-down-fill stamp thumbs-down"</span>
          <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 16 16"</span>
        &gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
            <span class="hljs-attr">d</span>=<span class="hljs-string">"M6.956 14.534c.065.936.952 1.659 1.908 1.42l.261-.065a1.38 1.38 0 0 0 1.012-.965c.22-.816.533-2.512.062-4.51q.205.03.443.051c.713.065 1.669.071 2.516-.211.518-.173.994-.68 1.2-1.272a1.9 1.9 0 0 0-.234-1.734c.058-.118.103-.242.138-.362.077-.27.113-.568.113-.856 0-.29-.036-.586-.113-.857a2 2 0 0 0-.16-.403c.169-.387.107-.82-.003-1.149a3.2 3.2 0 0 0-.488-.9c.054-.153.076-.313.076-.465a1.86 1.86 0 0 0-.253-.912C13.1.757 12.437.28 11.5.28H8c-.605 0-1.07.08-1.466.217a4.8 4.8 0 0 0-.97.485l-.048.029c-.504.308-.999.61-2.068.723C2.682 1.815 2 2.434 2 3.279v4c0 .851.685 1.433 1.357 1.616.849.232 1.574.787 2.132 1.41.56.626.914 1.28 1.039 1.638.199.575.356 1.54.428 2.591"</span>
          /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;<span class="hljs-regexp">/section&gt;
&lt;/</span>template&gt;

</div></code></pre>
    </details>
    <hr />
    <h2 id="05-0603-25">05-06/03-25</h2>
    <h3 id="knappfunktionallitet-parprogrammering-med-elin">
      Knappfunktionallitet parprogrammering med Elin
    </h3>
    <p>
      Vi vill att när knapparna ska göra att aktuellt kort får atributet
      hasAnswer = true när en knapp klickas och beroende på om man svarat rätt
      eller fel får needsPractice = true/false. Detta för att vi ska kunna spara
      sessionens statistik när alla kort är besvarade.
    </p>
    <p><img src="images/button-action.gif" alt="button action" /></p>
    <p>
      Elin har krigat länge med dessa knappar men stött på en märklig grej. Hur
      hon än gjorde så kunde dök inte frågan upp på flashcardet. Hon trodde att
      det var kod som hon gjort som orsakat detta, men hur mycket hon än ändrade
      sin kod fram och tillbaks gick det inte.. Fram tills vi parprogrammerade,
      då insåg jag att hon har en gammal localstorage som sidan hämtar
      information från, den ger svaret i form av card.title, men det ändrade vi
      ganska tidigt till card.question. Så hon hade alltså missat att rensa
      localstorage för att få det nya genererade cards objektet.
      <br />
      <br />
      Knapparnas funktionallitet satt vi på varsin ände och försökte lösa. Efter
      ett tag var jag tvungen att pysa iväg och när jag kom tillbaka så var de
      fixade, så den delen löste hon.
    </p>
    <hr />
    <h3 id="exportera-till-statistik">Exportera till statistik</h3>
    <p>
      Tack vare att knapparna nu fungerar kan jag känna av ifall alla kort är
      svarade och om de är det så ska <strong>deck.cards</strong> exporteras
      till <strong>deck.stats.sessions</strong>.
      <br />
      <br />
      Där <strong>deck.cards</strong> är en array med alla kort och sessions är
      en array som inehåller snapshots av korten och vad de hade för värde efter
      att användaren gissat rätt/fel per kort.
    </p>
    <p><img src="images/export-stats.gif" alt="exports stats" /></p>
    <p>
      <strong
        >Notera att först finns ingen statistik för 1:ans gångertabell, men när
        alla kort har ett svar så exporteras statistiken och alla korts data
        återställs (går från färgade till gråa ögonblicket sista frågan är
        besvarad)</strong
      >
    </p>
    <details>
      <summary>Visa kod för: src/view/CardView.vue</summary>
      <h3 id="allisanswered">allIsAnswered()</h3>
      <p>
        När denna funktion kallas går den igenom alla kort för att se om de är
        besvarade, skulle det vara så att minst ett är obesvarat så ändras
        variablen allIsAnswer till false. En miss jag gjorde i början var att
        retunera false i foreach loopen, men efter som att foreach är en
        funktion i sig så är det inte allIsAnwered som retunerar false, vilket
        resulterade i att funktionen alltid retunerade true oavsett hur många
        kort som var obesvarade. Himla tur att det löste sig!
      </p>
      <pre class="hljs"><code><div><span class="hljs-comment">/**
 * check if all cards hasAnswer = true
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">allIsAnswered</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> allIsAnswer = <span class="hljs-literal">true</span>;
  currentDeck.value.cards.forEach(<span class="hljs-function">(<span class="hljs-params">card</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!card.hasAnswer) {
      allIsAnswer = <span class="hljs-literal">false</span>;
    }
  });
  <span class="hljs-keyword">return</span> allIsAnswer;
}
</div></code></pre>
      <h3 id="exportdecktostats">exportDeckToStats()</h3>
      <p>
        Denna kodsnutt för till en början en del av allIsAnswered() men bestämde
        mig för att sepparera den till en egen funktion. Anledningen för att jag
        tyckte att allIsAnswered namnet passade bra i en if-sats och när det
        villkoret går igenom känns det naturligt att utföra exporten av kortet
        till statistiken.
      </p>
      <pre class="hljs"><code><div><span class="hljs-comment">/**
 * Push current session to decks session
 * */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exportDeckToStats</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> cardsCopy = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(currentDeck.value.cards));
  currentDeck.value.stats.sessions.push(cardsCopy);
  flashcard.updateStats(currentDeck.value);
  currentDeck.value.cards.forEach(<span class="hljs-function">(<span class="hljs-params">card</span>) =&gt;</span> (card.hasAnswer = <span class="hljs-literal">false</span>));
}
</div></code></pre>
      <p>
        Här skapar den en kopia av aktiella kortlekens kort med värden som
        användaren orsakat och sparar det i kortlekens statistik. Först försökte
        jag klona cards genom att utföra
      </p>
      <pre
        class="hljs"
      ><code><div><span class="hljs-keyword">const</span> cardsCopy = [...currentDeck.cards];
</div></code></pre>
      <p>
        Men märkte att så fort jag ändrade currentDeck.cards så ändrades även
        värdet i currentDeck.stats.sessions så alla kort som hade olika true och
        false variablen needPractice och alla variabler hasAnser blev nollade
        till false. Jon hjälpte mig genom att visa följande sätt att kopiera en
        array på
      </p>
      <pre
        class="hljs"
      ><code><div><span class="hljs-keyword">const</span> cardsCopy = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(currentDeck.value.cards));
</div></code></pre>
      <p>Vilket inte är vackert men det gör jobbet.</p>
      <h3 id="kollar-om-alla-%C3%A4r-besvarade-vid-r%C3%A4ttfel">
        Kollar om alla är besvarade vid rätt/fel
      </h3>
      <p>
        Utmaningen var att veta när jag skulle kolla om alla kort var besvarde.
        Jag slängde in några console.logs som jag hoppades på skulle spotta ut
        loggar då jag förväntade mig att hasAnswer skulle dubbelkollas. Det tog
        mig till dessa två funktiner, antingen när korten markeras som korrekt
        eller practice. Här var det passande att först kolla om alla är
        besvarade och isåfall exportera kortleken till sessionerna.
      </p>
      <pre
        class="hljs"
      ><code><div><span class="hljs-comment">// Correct toggle</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markAsCorrect</span>(<span class="hljs-params">card</span>) </span>{
  <span class="hljs-keyword">if</span> (!card.hasAnswer) {
    card.hasAnswer = <span class="hljs-literal">true</span>;
    card.needsPractice = <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">if</span> (allIsAnswered()) {
    exportDeckToStats();
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markAsPractice</span>(<span class="hljs-params">card</span>) </span>{
  <span class="hljs-keyword">if</span> (!card.hasAnswer) {
    card.hasAnswer = <span class="hljs-literal">true</span>;
    card.needsPractice = <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">if</span> (allIsAnswered()) {
    exportDeckToStats();
  }
}
</div></code></pre>
    </details>
    <hr />
    <h2 id="0703-25---anv%C3%A4ndartest-justeringar">
      07/03-25 - Användartest justeringar
    </h2>
    <h3 id="byte-av-knapptext">Byte av knapptext</h3>
    <h3 id="keybinds">Keybinds</h3>
    <p>
      Har lagt till så när man har en screenwidth som desktop får man
      &quot;tooltips&quot; för vilka knappar man kan trycka på för att slippa
      använda musen för att trycka på knapparna
    </p>
    <h4 id="desktop">Desktop</h4>
    <p><img src="images/buttons-desktop.png" alt="buttons desktop" /></p>
    <h4 id="telefon">Telefon</h4>
    <p><img src="images/buttons-phone.png" alt="buttons phone" /></p>
    <details>
      <summary>Visa kod för knappar</summary>
      <pre
        class="hljs"
      ><code><div><span class="hljs-comment">// Retunerar bool beroende på screenwidht</span>
<span class="hljs-keyword">const</span> isMobile = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.innerWidth &lt; <span class="hljs-number">768</span>;
};

<span class="hljs-comment">// Sätter text beroende på enhet</span>
<span class="hljs-keyword">const</span> correctButtonText = isMobile()
  ? <span class="hljs-string">"I know this one"</span>
  : <span class="hljs-string">"I know this one (a)"</span>;
<span class="hljs-keyword">const</span> practiceButtonText = isMobile()
  ? <span class="hljs-string">"Practice needed"</span>
  : <span class="hljs-string">"Practice needed (s)"</span>;
<span class="hljs-keyword">const</span> showAnswerText = isMobile() ? <span class="hljs-string">"Show answer"</span> : <span class="hljs-string">"Show answer (space)"</span>;
<span class="hljs-keyword">const</span> showQuestionText = isMobile() ? <span class="hljs-string">"Show question"</span> : <span class="hljs-string">"Show question (space)"</span>;
<span class="hljs-keyword">let</span> deckId = route.params.deckId;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>{{ correctButtonText }}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>{{ practiceButtonText }}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  /.../
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>;
</div></code></pre>
    </details>
    <hr />
    <h3 id="startsida-rubrik">Startsida rubrik</h3>
    <p>
      Efter användartest insåg jag att det behövs vara mer självklart att
      användaren faktiskt befinner sig på en flashcard sida, så lade till
      rubriken 'Your flashcard collection'
    </p>
    <p><img src="images/flashcard-header.png" alt="flashcard header" /></p>
    <hr />
    <h3 id="upp-till-3x-practice-f%C3%B6rs%C3%B6k">
      Upp till 3x practice försök
    </h3>
    <p>
      Användaren vill såklart lära sig sina flashcards, så jag lade till
      funktionalliteten att om man inte kan ett kort så läggs det till i slutet
      av leken upp till 2gånger, så man totalt får &quot;misslyckas&quot; 3x
      gånger. Observera den annorlunda stilsättningen på &quot;plupparna&quot;
      som dyker upp när användaren trycker &quot;need practice&quot;
    </p>
    <p><img src="images/3x-practice.gif" alt="3x practice" /></p>
    <details>
      <summary>Visa kod för CardView.vue</summary>
      När ett kort markeras som "practice" skapas ett kort som får isClone=true
      <br />
      detta för att sen kunna radera bort alla clon kort vid exporteringen till
      statistiken
      <br />
      koden innut i //--3x Fu.. är ny för denna funktionallitet
      <pre
        class="hljs"
      ><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markAsPractice</span>(<span class="hljs-params">card</span>) </span>{
  <span class="hljs-keyword">if</span> (!card.hasAnswer) {
    <span class="hljs-comment">//---- 3x Funktionallitet --- --- --- --- --- --- --- --- ---</span>
    <span class="hljs-keyword">const</span> copy = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(card));
    copy.isClone = <span class="hljs-literal">true</span>;

    <span class="hljs-comment">// Kollar att längden på tillagda specifikt kort inte överstiger 3, isåfall lägg</span>
    <span class="hljs-comment">// kopia i slutet av leken</span>
    <span class="hljs-keyword">if</span> (
      currentDeck.value.cards.filter(<span class="hljs-function">(<span class="hljs-params">card</span>) =&gt;</span> card.id === copy.id).length &lt;
      maxPracticeRepeat
    ) {
      currentDeck.value.cards.push(copy);
    }
    <span class="hljs-comment">//---- 3x Funktionallitet --- --- --- --- --- --- --- --- ---</span>
    card.hasAnswer = <span class="hljs-literal">true</span>;
    card.needsPractice = <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">if</span> (allIsAnswered()) {
    showAlert.value = <span class="hljs-literal">true</span>;
  }
}
</div></code></pre>
      <p>
        Tack vare att jag gett klonerna isClone=true kan jag lätt filtrera bort
        dom innan
        <br />
        exporten och även ta bort klonerna från currentDeck, så den inte fylls
        med mängder av
        <br />
        kloner på sikt.
      </p>
      <pre class="hljs"><code><div><span class="hljs-comment">/**
 * Push current session to decks session
 * */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exportDeckToStats</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Sparar alla kort som inte är kloner</span>
  <span class="hljs-keyword">const</span> cardsCopy = <span class="hljs-built_in">JSON</span>.parse(
    <span class="hljs-built_in">JSON</span>.stringify(currentDeck.value.cards.filter(<span class="hljs-function">(<span class="hljs-params">card</span>) =&gt;</span> !card.isClone))
  );
  <span class="hljs-comment">// Exporterar session</span>
  currentDeck.value.stats.sessions.push(cardsCopy);
  flashcard.updateStats(currentDeck.value);
  <span class="hljs-comment">// Tar bort de tillagda klonerna från korlekens ursprungliga kort</span>
  currentDeck.value.cards = currentDeck.value.cards.filter(
    <span class="hljs-function">(<span class="hljs-params">card</span>) =&gt;</span> !card.isClone
  );
  <span class="hljs-comment">// Nollställer kortens värden</span>
  currentDeck.value.cards.forEach(<span class="hljs-function">(<span class="hljs-params">card</span>) =&gt;</span> (card.hasAnswer = <span class="hljs-literal">false</span>));
  showAlert.value = <span class="hljs-literal">false</span>;
}
</div></code></pre>
      <p>
        tack vare att klonerna har eget atribut kan jag även utöka min gamla
        dotStyle
        <br />
        för att tillge klonerna egna stilsättningar.
      </p>
      <pre
        class="hljs"
      ><code><div><span class="hljs-comment">// Dots under flashcards</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dotStyle</span>(<span class="hljs-params">currentCard</span>) </span>{
  <span class="hljs-keyword">const</span> cardIndex = <span class="hljs-number">1</span> + currentDeck.value.cards.indexOf(currentCard);
  <span class="hljs-keyword">let</span> styleSettings = <span class="hljs-string">"dot "</span>;
  watchEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> cardNr = <span class="hljs-built_in">parseInt</span>(route.params.cardNr);
    <span class="hljs-keyword">if</span> (cardIndex === cardNr) {
      styleSettings += <span class="hljs-string">"current "</span>;
    }
  });
  <span class="hljs-keyword">if</span> (currentCard.hasAnswer &amp;&amp; !currentCard.needsPractice) {
    styleSettings += <span class="hljs-string">"correct "</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentCard.hasAnswer &amp;&amp; currentCard.needsPractice) {
    styleSettings += <span class="hljs-string">"wrong "</span>;
  }
  <span class="hljs-comment">// Lägger till class "clone" till 'dot' diven</span>
  <span class="hljs-keyword">if</span> (currentCard.isClone) {
    styleSettings += <span class="hljs-string">"clone "</span>;
  }
  <span class="hljs-keyword">return</span> styleSettings;
}
</div></code></pre>
      <p>clone css</p>
      <pre
        class="hljs"
      ><code><div><span class="hljs-selector-class">.clone</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>;
  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">2px</span> <span class="hljs-built_in">var</span>(--grey);
}
</div></code></pre>
    </details>
    <hr />
    <h2 id="1003-25">10/03-25</h2>
    <h3 id="flip-card-med-mus-pekaren">Flip card med mus pekaren</h3>
    <p>
      Under användartesterna märkte jag att många ville trycka på korten i
      förväntan på att något skulle hända. Inget hände då för vi hade inte
      implementerat funktionalliteten. Men med en enkel
      @click=&quot;toggleAnswer&quot; implementerades den funktionalliteten.
      <br />
      Känns även schysst mot användaren att kunna snegla på svaret för det kort
      man har svårast för på statistik sidan.
    </p>
    <p><img src="images/mouse-answer.gif" alt="mouse flip" /></p>
    <details>
      <summary>
        Visa kod för: src/view/CardView.vue och src/compoments/FlashCard.vue
      </summary>
      <h3 id="toggleanswer">ToggleAnswer</h3>
      <p>
        Eftersom vi har en toggleAnswer function i CardView kan vi med emit
        skicka en signal från <br />
        FlashCard.vue som signalerar att kortet ska byta sida
      </p>
      <pre class="hljs"><code><div>
<span class="hljs-comment">//  Script CardView.vue</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleAnswer</span>(<span class="hljs-params"></span>) </span>{
  hideAnswer.value = !hideAnswer.value;
}
<span class="hljs-comment">// Template CardView.vue</span>
&lt;FlashCard
  @on-deck-update=<span class="hljs-string">"updateDeck"</span>
  :hide-answer=<span class="hljs-string">"hideAnswer"</span>
  @toggle-answer=<span class="hljs-string">"toggleAnswer"</span>
  @on-reset-answer=<span class="hljs-string">"resetAnswer"</span>
  @mark-<span class="hljs-keyword">as</span>-correct=<span class="hljs-string">"markAsCorrect"</span>
  @mark-<span class="hljs-keyword">as</span>-practice=<span class="hljs-string">"markAsPractice"</span>
/&gt;

<span class="hljs-comment">// -----------------------------------</span>

<span class="hljs-comment">// Script FlashCard.vue</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleAnswer</span>(<span class="hljs-params"></span>) </span>{
  emit(<span class="hljs-string">"toggle-answer"</span>);
}

<span class="hljs-comment">// Template FlashCard.vue</span>
&lt;div
  v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"hideAnswer"</span>
  <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"flashcard-content"</span>
  id=<span class="hljs-string">"front"</span>
  @click=<span class="hljs-string">"toggleAnswer"</span>&gt;
  {{ currentCard.question }}
&lt;<span class="hljs-regexp">/div&gt;

&lt;div v-else class="flashcard-content" id="back" @click="toggleAnswer"&gt;
  {{ currentCard.answer }}
&lt;/</span>div&gt;
</div></code></pre>
    </details>
    <hr />
    <h1 id="sammanfattning">Sammanfattning</h1>
    <p>
      Jag har lärt mig att det underlättar att reducera mängden komponenter
      ifall man bygger funktionallitet där saker och ting komminucerar mycket
      med varrandra. Å andra sidan, om man använder pinia så kan man komma runt
      custom events och props när det kommer till komponent kommunikation.
      <br />
      <br />
      En stor utmaning har varit att hitta gemensamma lösningar med gruppen. Jag
      upplevde att det blir lätt Frankenstein lösningar, där man klipper och
      klistrar tills det funkar, utan att följa ett och samma mönster. Lösningen
      på det tror jag är en kombination av programmerings erfarenhet och tydlig
      kommunikation. Största utmaningen blir när två individer påstår sig vara
      den som sitter på den bästa lösningen, då hade nog bästa scenariot varit
      att ha en senior som kan lyssna in båda förslagen och sedan ta ett beslut
      som alla får vika sig för.
      <br />
      <br />
      Det har varit otroligt lärorikt och jag vågar påstå att jag har god
      förståelse för hur VUE ramverk fungerar och jag ser möjligheterna i hur
      ramverket underlättar arbetet i hemsidobyggandet.
      <br />
      <br />
      Tack för att du läste dig såhär långt.
    </p>
    <details>
      <summary>Klicka för att se kod:</summary>
      <pre
        class="hljs"
      ><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUserAHero</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (userMadeItThisFar) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</div></code></pre>
    </details>
  </body>
</html>
